{"version":3,"sources":["Utilities/SemanticLocationHistory/2015/semantic-location-history-NOVEMBER2015.ts"],"names":["Convert","json","val","JSON","parse","typ","r","transform","jsonToJSProps","value","stringify","jsToJSONProps","invalidValue","Error","undefined","jsonToJS","map","props","forEach","p","key","js","jsToJSON","getProps","ref","typeMap","Array","isArray","cases","indexOf","transformEnum","hasOwnProperty","typs","l","length","i","_","transformUnion","unionMembers","el","transformArray","arrayItems","additional","result","Object","getOwnPropertyNames","prop","v","prototype","call","transformObject","Date","d","isNaN","valueOf","transformDate","transformPrimitive","o","name"],"mappings":"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","file":"static/js/3.3583d1d6.chunk.js","sourcesContent":["// To parse this data:\n//\n//   import { Convert, SemanticLocationHistoryNOVEMBER2015 } from \"./file\";\n//\n//   const semanticLocationHistoryNOVEMBER2015 = Convert.toSemanticLocationHistoryNOVEMBER2015(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface SemanticLocationHistoryNOVEMBER2015 {\n    timelineObjects: TimelineObject[];\n}\n\nexport interface TimelineObject {\n    placeVisit: PlaceVisit;\n}\n\nexport interface PlaceVisit {\n    location:    Location;\n    duration:    Duration;\n    centerLatE7: number;\n    centerLngE7: number;\n}\n\nexport interface Duration {\n    startTimestampMs: string;\n    endTimestampMs:   string;\n}\n\nexport interface Location {\n    latitudeE7:  number;\n    longitudeE7: number;\n    placeId:     string;\n    address:     string;\n    name:        string;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n    public static toSemanticLocationHistoryNOVEMBER2015(json: string): SemanticLocationHistoryNOVEMBER2015 {\n        return cast(JSON.parse(json), r(\"SemanticLocationHistoryNOVEMBER2015\"));\n    }\n\n    public static semanticLocationHistoryNOVEMBER2015ToJson(value: SemanticLocationHistoryNOVEMBER2015): string {\n        return JSON.stringify(uncast(value, r(\"SemanticLocationHistoryNOVEMBER2015\")), null, 2);\n    }\n}\n\nfunction invalidValue(typ: any, val: any): never {\n    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);\n}\n\nfunction jsonToJSProps(typ: any): any {\n    if (typ.jsonToJS === undefined) {\n        var map: any = {};\n        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });\n        typ.jsonToJS = map;\n    }\n    return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n    if (typ.jsToJSON === undefined) {\n        var map: any = {};\n        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });\n        typ.jsToJSON = map;\n    }\n    return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any): any {\n    function transformPrimitive(typ: string, val: any): any {\n        if (typeof typ === typeof val) return val;\n        return invalidValue(typ, val);\n    }\n\n    function transformUnion(typs: any[], val: any): any {\n        // val must validate against one typ in typs\n        var l = typs.length;\n        for (var i = 0; i < l; i++) {\n            var typ = typs[i];\n            try {\n                return transform(val, typ, getProps);\n            } catch (_) {}\n        }\n        return invalidValue(typs, val);\n    }\n\n    function transformEnum(cases: string[], val: any): any {\n        if (cases.indexOf(val) !== -1) return val;\n        return invalidValue(cases, val);\n    }\n\n    function transformArray(typ: any, val: any): any {\n        // val must be an array with no invalid elements\n        if (!Array.isArray(val)) return invalidValue(\"array\", val);\n        return val.map(el => transform(el, typ, getProps));\n    }\n\n    function transformDate(val: any): any {\n        if (val === null) {\n            return null;\n        }\n        const d = new Date(val);\n        if (isNaN(d.valueOf())) {\n            return invalidValue(\"Date\", val);\n        }\n        return d;\n    }\n\n    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n            return invalidValue(\"object\", val);\n        }\n        var result: any = {};\n        Object.getOwnPropertyNames(props).forEach(key => {\n            const prop = props[key];\n            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n            result[prop.key] = transform(v, prop.typ, getProps);\n        });\n        Object.getOwnPropertyNames(val).forEach(key => {\n            if (!Object.prototype.hasOwnProperty.call(props, key)) {\n                result[key] = transform(val[key], additional, getProps);\n            }\n        });\n        return result;\n    }\n\n    if (typ === \"any\") return val;\n    if (typ === null) {\n        if (val === null) return val;\n        return invalidValue(typ, val);\n    }\n    if (typ === false) return invalidValue(typ, val);\n    while (typeof typ === \"object\" && typ.ref !== undefined) {\n        typ = typeMap[typ.ref];\n    }\n    if (Array.isArray(typ)) return transformEnum(typ, val);\n    if (typeof typ === \"object\") {\n        return typ.hasOwnProperty(\"unionMembers\") ? transformUnion(typ.unionMembers, val)\n            : typ.hasOwnProperty(\"arrayItems\")    ? transformArray(typ.arrayItems, val)\n            : typ.hasOwnProperty(\"props\")         ? transformObject(getProps(typ), typ.additional, val)\n            : invalidValue(typ, val);\n    }\n    // Numbers can be parsed by Date but shouldn't be.\n    if (typ === Date && typeof val !== \"number\") return transformDate(val);\n    return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n    return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n    return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n    return { arrayItems: typ };\n}\n\n\nfunction o(props: any[], additional: any) {\n    return { props, additional };\n}\n\n\nfunction r(name: string) {\n    return { ref: name };\n}\n\nconst typeMap: any = {\n    \"SemanticLocationHistoryNOVEMBER2015\": o([\n        { json: \"timelineObjects\", js: \"timelineObjects\", typ: a(r(\"TimelineObject\")) },\n    ], false),\n    \"TimelineObject\": o([\n        { json: \"placeVisit\", js: \"placeVisit\", typ: r(\"PlaceVisit\") },\n    ], false),\n    \"PlaceVisit\": o([\n        { json: \"location\", js: \"location\", typ: r(\"Location\") },\n        { json: \"duration\", js: \"duration\", typ: r(\"Duration\") },\n        { json: \"centerLatE7\", js: \"centerLatE7\", typ: 0 },\n        { json: \"centerLngE7\", js: \"centerLngE7\", typ: 0 },\n    ], false),\n    \"Duration\": o([\n        { json: \"startTimestampMs\", js: \"startTimestampMs\", typ: \"\" },\n        { json: \"endTimestampMs\", js: \"endTimestampMs\", typ: \"\" },\n    ], false),\n    \"Location\": o([\n        { json: \"latitudeE7\", js: \"latitudeE7\", typ: 0 },\n        { json: \"longitudeE7\", js: \"longitudeE7\", typ: 0 },\n        { json: \"placeId\", js: \"placeId\", typ: \"\" },\n        { json: \"address\", js: \"address\", typ: \"\" },\n        { json: \"name\", js: \"name\", typ: \"\" },\n    ], false),\n};\n"],"sourceRoot":""}